<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta
            content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"
            name="viewport"
        />
        <meta content="ie=edge" http-equiv="X-UA-Compatible" />
        <link rel="icon" href="./assets/mipmap/icon.png" />
        <title>PassionPenguin/RailMapMaker</title>
        <style>
            body {
                background: #fff;
                margin: 0;
            }

            #drawable {
                position: absolute;
                left: 0;
                top: 0;
                z-index: 1;
                width: 5000px;
                height: 5000px;
            }

            #resSvg {
                width: 5000px;
                height: 5000px;
            }

            #cursor {
                overflow: hidden;
                width: 5px;
                height: 5px;
                background: darkred;
                position: fixed;
                z-index: 2;
                transition: 50ms;
                border-radius: 50%;
                transform: translate(-50%, -50%);
            }

            #pg-app {
                width: 100vw;
                height: 100vh;
                overflow: scroll;
                position: relative;
            }

            #resSvg {
                position: absolute;
                left: 0;
                top: 0;
            }

            #resSvg path {
                stroke-width: 5px;
                fill: transparent;
            }

            #lineEditorPrompt {
                position: fixed;
                bottom: 0;
                left: 0;
                width: 100%;
                height: 400px;
                background: #fff;
                z-index: 2;
                border-radius: 10px 10px 0 0;
            }

            #lineEditorColorPicker,
            #lineEditorOpacityPicker,
            #lineEditorNameInput {
                display: block;
                width: 200px;
                height: 36px;
                background: transparent;
                border: 0;
                outline: none;
                font: 14px/1 Anodina, sans-serif;
                text-align: left;
                margin: 0 auto;
                white-space: pre;
                color: #444;
            }

            #lineEditorPrompt .typeInfo {
                width: 200px;
                height: 24px;
                text-align: left;
                margin: 20px auto 0;
                font: 900 12px/2 Anoidina, sans-serif;
                padding-left: 15px;
            }
        </style>
        <link rel="stylesheet" href="./dist/libs/bundle/PenguinUI/bundle.PenguinUI.css" />
        <link rel="stylesheet" href="./dist/libs/bundle/storyboard/bundle.storyboard.css" />
    </head>
    <body>
        <div id="pg-app"></div>

        <script src="./dist/libs/build.package.js"></script>
        <script>
            window.pg = {
                $: e => {
                    return document.querySelectorAll(e);
                },
            };

            window.Int = val => {
                return parseInt(val);
            };

            window.cE = data => {
                if (data === undefined)
                    data = { type: 'div', attr: [], innerText: undefined, innerHTML: undefined, onclick: undefined };
                let e = document.createElement(data.type);
                if (data.attr !== undefined)
                    data.attr.forEach(attr => {
                        e.setAttribute(attr[0], attr[1]);
                    });
                if (data.innerText !== undefined) e.innerText = data.innerText;
                if (data.innerHTML !== undefined) e.innerHTML = data.innerHTML;
                if (data.onclick !== undefined)
                    e.onclick = e => {
                        data.onclick(e);
                    };
                return e;
            };

            window.min = val => {
                return val % 25 > 12.5 ? val + (25 - (val % 25)) : val - (val % 25);
            };

            if (!Array.prototype.last) {
                Array.prototype.last = function() {
                    return this[this.length - 1];
                };
            }

            builder.importScripts(['./dist/libs/bundle/PenguinUI/bundle.PenguinUI.js'], () => {
                initPenguinUI(() => {
                    ProgressManager.create(0, 0, 0);

                    builder.init(() => {
                        initInterface(0);

                        window.reloadMap = id => {
                            const map = pathInfo[id];
                            const pathElement = pg.$('#UnnamedPath_' + id)[0];
                            const stationsElement = pg.$('#UnnamedStations_' + id)[0];
                            stationsElement.innerHTML = '';

                            pathElement.setAttributeNS(null, 'd', 'M' + map.stations[0].x + ' ' + map.stations[0].y);

                            let shouldBeCompressed = false,
                                shouldBeLonger = false;

                            const createPath = (Coordinate, place, override) => {
                                /*
                                 *
                                 * Coordinate: normally, an array of three ([[x1,y1],[x2,y2],[x3,y3]]). (while map.stations.length>2)
                                 * direction: while is not a parallel line, choose upper or lower
                                 * override: while map.stations.length === 2
                                 *
                                 * */
                                let perpendicular = false;
                                if (!override) {
                                    try {
                                        if (
                                            (Coordinate[0][0] - Coordinate[1][0]) /
                                                (Coordinate[0][1] - Coordinate[1][1]) ===
                                            ((Coordinate[1][0] - Coordinate[2][0]) /
                                                (Coordinate[1][1] - Coordinate[2][1])) *
                                                -1
                                        )
                                            perpendicular = true;
                                    } catch (e) {}
                                    try {
                                        if (
                                            (Coordinate[0][0] === Coordinate[1][0] &&
                                                Coordinate[1][1] === Coordinate[2][1]) ||
                                            (Coordinate[0][1] === Coordinate[1][1] &&
                                                Coordinate[1][0] === Coordinate[2][0])
                                        )
                                            perpendicular = true;
                                    } catch (e) {}
                                }

                                if (perpendicular || Coordinate[0][0] === Coordinate[1][0]) {
                                    console.log('v ' + Coordinate);
                                    // Parallel to the y-axis
                                    if (Coordinate[0][0] === Coordinate[2][0] || override || perpendicular) {
                                        if (shouldBeCompressed) {
                                            shouldBeCompressed = false;
                                            return (
                                                ' v ' +
                                                (Coordinate[1][1] - Coordinate[0][1] > 0
                                                    ? Coordinate[1][1] - Coordinate[0][1] - 50
                                                    : Coordinate[1][1] - Coordinate[0][1] + 50)
                                            );
                                        } else return ' v ' + (Coordinate[1][1] - Coordinate[0][1]);
                                    } else shouldBeCompressed = true;
                                } else if (perpendicular || Coordinate[0][1] === Coordinate[1][1]) {
                                    console.log('h ' + Coordinate);
                                    // Parallel to the x-axis
                                    if (Coordinate[0][1] === Coordinate[2][1] || override || perpendicular) {
                                        if (shouldBeCompressed) {
                                            shouldBeCompressed = false;
                                            return (
                                                ' h ' +
                                                (Coordinate[1][0] - Coordinate[0][0] > 0
                                                    ? Coordinate[1][0] - Coordinate[0][0] - 50
                                                    : Coordinate[1][0] - Coordinate[0][0] + 50)
                                            );
                                        } else return ' h ' + (Coordinate[1][0] - Coordinate[0][0]);
                                    } else shouldBeLonger = true;
                                }

                                let direction;
                                if (Coordinate[0][0] > Coordinate[1][0]) {
                                    // x-axis-direction to left
                                    if (Coordinate[0][1] < Coordinate[1][1])
                                        // y-axis-direction to bottom, to left-bottom
                                        direction = 0;
                                    // y-axis-direction to top, to left-top
                                    else direction = 1;
                                } else {
                                    // x-axis-direction to right
                                    if (Coordinate[0][1] < Coordinate[1][1])
                                        // y-axis-direction to bottom, to right-bottom
                                        direction = 2;
                                    // y-axis-direction to top, to right-top
                                    else direction = 3;
                                }

                                let abs_horn = Math.abs(Coordinate[0][0] - Coordinate[1][0]),
                                    abs_vert = Math.abs(Coordinate[0][1] - Coordinate[1][1]),
                                    rest_horn = abs_horn - 50 > 0 ? abs_horn - 50 : abs_horn,
                                    rest_vert = abs_vert - 50 > 0 ? abs_vert - 50 : abs_vert;

                                if (shouldBeLonger) {
                                    let index = -1;
                                    map.stations.forEach((e, i) => {
                                        if (e.x === Coordinate[0][0] && e.y === Coordinate[0][1]) index = i;
                                    });
                                    if (index === -1) return;
                                    rest_horn = Math.abs(rest_horn + Coordinate[0][0] - map.stations[index - 1].x);
                                    rest_vert = Math.abs(rest_vert + Coordinate[0][1] - map.stations[index - 1].y);
                                }

                                console.log(direction, Coordinate, abs_vert, abs_horn, rest_vert, rest_horn);

                                if ([0, 1, 2, 3].indexOf(direction) !== -1) shouldBeCompressed = true;

                                switch (direction) {
                                    case 0:
                                        // left-bottom
                                        if (place === 'upper')
                                            return ' h -' + rest_horn + ' c -50 0 -50 0 -50 50 v ' + rest_vert;
                                        else return ' v ' + rest_vert + 'c 0 50 0 50 -50 50 h -' + rest_horn;
                                    case 1:
                                        // left-top
                                        if (place === 'upper')
                                            return ' v -' + rest_vert + ' c 0 -50 0 -50 -50 -50 h -' + rest_horn;
                                        else return ' h -' + rest_horn + ' c -50 0 -50 0 -50 -50 v -' + rest_vert;
                                    case 2:
                                        // right-bottom
                                        if (place === 'upper')
                                            return ' h ' + rest_horn + ' c 50 0 50 0 50 50 v ' + rest_vert;
                                        else return ' v ' + rest_vert + 'c 0 50 0 50 50 50 h ' + rest_horn;
                                    case 3:
                                        // right-top
                                        if (place === 'upper')
                                            return ' v -' + rest_vert + ' c 0 50 0 50 50 -50 h ' + rest_horn;
                                        else return ' h ' + rest_horn + ' c 50 0 50 0 50 -50 v -' + rest_vert;
                                }
                            };

                            let path = pathElement.getAttributeNS(null, 'd');
                            let [prevX, prevY] = [map.stations.x, map.stations.y];

                            map.stations.forEach((e, i) => {
                                let stationNode = document.createElementNS(pg.$('#resSvg')[0].namespaceURI, 'use');
                                stationNode.setAttributeNS(null, 'href', '#stationStyle_' + state.stationStyle);
                                stationNode.setAttributeNS(null, 'fill', map.color);
                                stationNode.setAttributeNS(null, 'x', '0');
                                stationNode.setAttributeNS(null, 'y', '0');
                                stationsElement.appendChild(stationNode);
                                stationNode.setAttributeNS(
                                    null,
                                    'style',
                                    'transform: matrix(1, 0, 0, 1, ' + (e.x - 8) + ', ' + (e.y - 8) + ');'
                                );
                                if (e.type === 'destination')
                                    stationNode.setAttributeNS(
                                        null,
                                        'style',
                                        'transform: matrix(1, 0, 0, 1, ' +
                                            (e.x - 12) +
                                            ', ' +
                                            (e.y - 12) +
                                            ') scale(1.5);'
                                    );

                                if (i > 0) {
                                    if (prevX === e.x) {
                                        path += `V${e.y}`;
                                    } else if (prevY === e.y) {
                                        path += `H${e.x}`;
                                    } else if (prevX > e.x && prevY > e.y) {
                                        path += `h${e.x - prevX + 10}a10,10,0,0,1-10-10V${e.y}`;
                                    } else if (prevX > e.x && prevY < e.y) {
                                        path += `h${e.x - prevX + 10}a10,10,0,0,0-10,10V${e.y}`;
                                    } else if (prevX < e.x && prevY > e.y) {
                                        let R = 30;
                                        let adx = (Math.sqrt(2) * R) / 2;
                                        let ady = R - adx;
                                        let dl = prevY - e.y - ady;
                                        let dx = e.x - prevX - adx - dl;
                                        path += `h${dx}a30,30,0,0,0,${adx},${-ady}L${e.x},${e.y}`;
                                    } else if (prevX < e.x && prevY < e.y) {
                                        let R = 30;
                                        let adx = (Math.sqrt(2) * R) / 2;
                                        let ady = R - adx;
                                        let dl = e.y - prevY - ady;
                                        let dx = e.x - prevX - adx - dl;
                                        // use L to avoid rounding error
                                        path += `h${dx}a30,30,0,0,1,${adx},${ady}L${e.x},${e.y}`;
                                    }
                                }

                                [prevX, prevY] = [e.x, e.y];
                            });
                            pathElement.setAttributeNS(null, 'd', path);

                            //     if (map.stations.length === 2) {
                            //         let Coordinate = [
                            //             [map.stations[0].x, map.stations[0].y],
                            //             [map.stations[1].x, map.stations[1].y],
                            //         ];
                            //         pathElement.setAttributeNS(
                            //             null,
                            //             'd',
                            //             pathElement.getAttributeNS(null, 'd') + createPath(Coordinate, '', true)
                            //         );
                            //     }
                            //     if (map.stations.length > 2) {
                            //         map.stations.forEach((e, index) => {
                            //             // Init Stations
                            //             if (e.type !== 'Auxiliary point') {
                            //                 let stationNode = document.createElementNS(
                            //                     pg.$('#resSvg')[0].namespaceURI,
                            //                     'use'
                            //                 );
                            //                 stationNode.setAttributeNS(null, 'href', '#stationStyle_' + state.stationStyle);
                            //                 stationNode.setAttributeNS(null, 'fill', map.color);
                            //                 stationNode.setAttributeNS(null, 'x', '0');
                            //                 stationNode.setAttributeNS(null, 'y', '0');
                            //                 stationsElement.appendChild(stationNode);
                            //                 stationNode.setAttributeNS(
                            //                     null,
                            //                     'style',
                            //                     'transform: matrix(1, 0, 0, 1, ' + (e.x - 8) + ', ' + (e.y - 8) + ');'
                            //                 );
                            //                 if (e.type === 'destination')
                            //                     stationNode.setAttributeNS(
                            //                         null,
                            //                         'style',
                            //                         'transform: matrix(1, 0, 0, 1, ' +
                            //                             (e.x - 12) +
                            //                             ', ' +
                            //                             (e.y - 12) +
                            //                             ') scale(1.5);'
                            //                     );
                            //             }

                            //             // Init Paths
                            //             if (!(index > map.stations.length - 3))
                            //                 pathElement.setAttributeNS(
                            //                     null,
                            //                     'd',
                            //                     pathElement.getAttributeNS(null, 'd') +
                            //                         createPath(
                            //                             [
                            //                                 [e.x, e.y],
                            //                                 [map.stations[index + 1].x, map.stations[index + 1].y],
                            //                                 [map.stations[index + 2].x, map.stations[index + 2].y],
                            //                             ],
                            //                             '',
                            //                             false
                            //                         )
                            //                 );
                            //         });
                            //         pathElement.setAttributeNS(
                            //             null,
                            //             'd',
                            //             pathElement.getAttributeNS(null, 'd') +
                            //                 createPath(
                            //                     [
                            //                         [
                            //                             map.stations[map.stations.length - 2].x,
                            //                             map.stations[map.stations.length - 2].y,
                            //                         ],
                            //                         [
                            //                             map.stations[map.stations.length - 1].x,
                            //                             map.stations[map.stations.length - 1].y,
                            //                         ],
                            //                     ],
                            //                     '',
                            //                     true
                            //                 )
                            //         );
                            //     }
                        };
                    });
                });
            });
        </script>
    </body>
</html>
